<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake â€” Classic HTML Game</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#22c55e;--muted:#94a3b8}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg),#071021);color:#e6eef8}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{background:rgba(255,255,255,0.03);padding:18px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6);display:flex;gap:18px;align-items:center}
    canvas{background:linear-gradient(180deg,#071422,#08202b);border-radius:8px;display:block}

    /* FIX: HUD width locked so Reset All never disappears */
    .hud{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-width:200px; 
      width:200px;      /* THIS FIXES THE MOBILE ISSUE */
    }

    .hud .row{display:flex;justify-content:space-between;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.07);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
    .btn.primary{border-color:var(--accent);color:var(--accent)}
    .btn.danger{border-color:#ff5555;color:#ff7777}
    .hint{font-size:13px;color:var(--muted)}
    .big{font-size:20px;font-weight:600}

    @media(max-width:720px){
      .card{flex-direction:column}
    }

    /* Title above Canvas */
    .playwrap{display:flex;flex-direction:column;align-items:center;gap:8px}
    .title{
      font-size:26px;
      font-weight:700;
      color:#0b6b44;
      text-shadow:0 0 6px rgba(11,107,68,0.28);
      margin-bottom:4px
    }

    /* Title above HUD */
    .sideTitle{
      text-align:center;
      font-size:28px;
      font-weight:700;
      margin-bottom:6px;
      color:white;
    }

  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">

      <div class="playwrap">
        <div class="title">Byte Serpent</div>
        <canvas id="game" width="480" height="480"></canvas>
      </div>

      <div class="hud">
        <div class="sideTitle">BYTE SERPENT</div>

        <div class="row"><div class="big">Score</div><div id="score">0</div></div>
        <div class="row"><div class="big">Best</div><div id="best">0</div></div>
        <div class="row"><div class="hint">Speed</div><div id="speed">6</div></div>

        <!-- Reset All stays EXACTLY where you originally had it -->
        <button id="resetAll" class="btn danger">Reset All</button>

        <div style="display:flex;gap:8px;margin-top:4px;">
          <button id="start" class="btn primary">Start</button>
          <button id="reset" class="btn">Reset</button>
        </div>

        <div class="hint">Controls: Arrow keys / WASD</div>
        <div class="hint">Try to eat the red food. Don't hit the walls or yourself.</div>
      </div>
    </div>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const speedEl = document.getElementById('speed');
const startBtn = document.getElementById('start');
const resetBtn = document.getElementById('reset');
const resetAllBtn = document.getElementById('resetAll');

const gridSize = 20;
const cols = canvas.width / gridSize;
const rows = canvas.height / gridSize;

let snake;
let dir;
let nextDir;
let food;

let tickInterval;
let tickTimer = null;

let running = false;
let dead = false;

let score = 0;
let best = Number(localStorage.getItem('snake_best') || 0);
bestEl.textContent = best;

// RESET ALL DATA
resetAllBtn.addEventListener('click', () => {
  localStorage.clear();
  best = 0;
  bestEl.textContent = 0;
  resetGame();
});

// RESET GAME
function resetGame(){
  snake = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
  dir = {x:1, y:0};
  nextDir = {x:1, y:0};

  placeFood();
  score = 0;
  tickInterval = 1000 / 6;

  running = false;
  dead = false;

  clearInterval(tickTimer);
  updateHud();
  draw();
}

function placeFood(){
  while(true){
    const x = Math.floor(Math.random()*cols);
    const y = Math.floor(Math.random()*rows);
    if(!snake.some(s => s.x===x && s.y===y)){
      food = {x,y};
      return;
    }
  }
}

function startGame(){
  if(running || dead) return;
  running = true;
  restartTicker();
}

function restartTicker(){
  clearInterval(tickTimer);
  tickTimer = setInterval(step, tickInterval);
}

function step(){
  if(nextDir.x !== -dir.x || nextDir.y !== -dir.y){
    dir = nextDir;
  }

  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

  if(head.x<0 || head.x>=cols || head.y<0 || head.y>=rows){
    gameOver(); return;
  }
  if(snake.some(s => s.x===head.x && s.y===head.y)){
    gameOver(); return;
  }

  snake.unshift(head);

  if(head.x === food.x && head.y === food.y){
    score++;
    placeFood();

    if(score % 3 === 0){
      tickInterval = Math.max(40, tickInterval * 0.9);
      restartTicker();
    }
  } else {
    snake.pop();
  }

  updateHud();
  draw();
}

function gameOver(){
  running = false;
  dead = true;
  clearInterval(tickTimer);

  if(score > best){
    best = score;
    localStorage.setItem('snake_best', String(best));
  }
  updateHud();

  canvas.style.boxShadow = '0 0 0 6px rgba(255,50,50,0.2)';
  setTimeout(()=> canvas.style.boxShadow = '', 500);

  draw();
}

function updateHud(){
  scoreEl.textContent = score;
  bestEl.textContent = best;
  speedEl.textContent = Math.round(1000/tickInterval);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#03151b';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  drawCell(food.x, food.y, '#ff4444');

  for(let i=snake.length-1;i>=0;i--){
    const s = snake[i];
    if(i===0) drawCell(s.x,s.y,'#8ef7b6', true);
    else drawCell(s.x,s.y,'#1de38a');
  }

  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  for(let x=0;x<=cols;x++){
    ctx.beginPath(); ctx.moveTo(x*gridSize,0); ctx.lineTo(x*gridSize,canvas.height); ctx.stroke();
  }
  for(let y=0;y<=rows;y++){
    ctx.beginPath(); ctx.moveTo(0,y*gridSize); ctx.lineTo(canvas.width,y*gridSize); ctx.stroke();
  }
}

function drawCell(cx, cy, color, isHead=false){
  const px = cx * gridSize;
  const py = cy * gridSize;
  const pad = 2;

  if(isHead){
    const g = ctx.createLinearGradient(px,py,px+gridSize,py+gridSize);
    g.addColorStop(0,color);
    g.addColorStop(1,'#0fffc2');
    ctx.fillStyle = g;
  } else ctx.fillStyle = color;

  roundRect(ctx, px+pad, py+pad, gridSize-2*pad, gridSize-2*pad, 6);
  ctx.fill();
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y, x+w,y+h, r);
  ctx.arcTo(x+w,y+h, x,y+h, r);
  ctx.arcTo(x,y+h, x,y, r);
  ctx.arcTo(x,y, x+w,y, r);
  ctx.closePath();
}

window.addEventListener('keydown', e => {
  const k = e.key;

  let moved = false;

  if(k==='ArrowUp'||k==='w'||k==='W'){ nextDir={x:0,y:-1}; moved = true; }
  if(k==='ArrowDown'||k==='s'||k==='S'){ nextDir={x:0,y:1}; moved = true; }
  if(k==='ArrowLeft'||k==='a'||k==='A'){ nextDir={x:-1,y:0}; moved = true; }
  if(k==='ArrowRight'||k==='d'||k==='D'){ nextDir={x:1,y:0}; moved = true; }

  if(moved){
    if(dead){
      resetGame();
      startGame();
    } else if(!running){
      startGame();
    }
  }

  if(k===' '){
    if(dead){
      resetGame();
    } else if(!running){
      startGame();
    }
  }
});

startBtn.addEventListener('click', startGame);
resetBtn.addEventListener('click', resetGame);

resetGame();
</script>
</body>
</html>
