<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake — Classic HTML Game</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#22c55e;--muted:#94a3b8}
    *{box-sizing:border-box}
    /* Set body overflow to hidden and adjusted wrap padding */
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg),#071021);color:#e6eef8; overflow: hidden;}
    .wrap{
        min-height:100vh;
        display:flex;
        align-items:center;
        justify-content:center;
        padding:12px; 
    }
    .card{
        background:rgba(255,255,255,0.03);
        padding:18px; 
        border-radius:12px;
        box-shadow:0 6px 24px rgba(2,6,23,0.6);
        display:flex;
        gap: 30px; 
        align-items: flex-start; 
        justify-content: center; 
    }
    canvas{
        background:linear-gradient(180deg,#071422,#08202b);
        border-radius:8px;
        display:block;
        transition: box-shadow 0.2s ease-out; 
    }
    .hud{
        display:flex;
        flex-direction:column;
        gap:10px;
        min-width:180px;
        /* Manually push the HUD down to visually align its center with the 480px canvas center */
        margin-top: 65px; 
    }
    .hud .row{display:flex;justify-content:space-between;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.07);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer; transition: background 0.1s}
    .btn.primary{border-color:var(--accent);color:var(--accent)}
    .btn.danger{border-color:#ef4444;color:#ef4444} 
    .btn.danger:hover{background: rgba(239, 68, 68, 0.1);}
    .btn.success{border-color:var(--accent);color:#fff;background:var(--accent)} 
    .hint{font-size:13px;color:var(--muted)}
    .big{font-size:20px;font-weight:600}

    .big, #score, #best {
        transition: color 0.2s ease-out;
    }
    
    .red-warning {
        color: #ff4444;
        font-weight: 600;
        text-transform: uppercase;
    }
    .green-control {
        color: var(--accent);
        font-weight: 600;
    }
    
    /* MOBILE STYLES START */
    @media(max-width:720px){
        .card{
            flex-direction:column;
            padding: 18px; 
            gap: 18px;
            align-items: center; 
        }
        .hud{
            width: 100%; 
            max-width: 480px; 
            /* Reset margin for mobile stacked layout */
            margin-top: 0; 
            /* OPTIMIZATION 1: Reduce vertical spacing in the HUD on mobile */
            gap: 5px; 
            padding: 10px 0; 
        }
        .hud .row{
            /* OPTIMIZATION 2: Make the score/best row text smaller */
            font-size: 16px; 
        }
        .hud .row .big {
            font-size: 16px; 
        }
        .hud .row, .hud-footer {
            max-width: 300px; 
            width: 100%;
            margin-left: auto;
            margin-right: auto;
        }
        .hud-footer {
            align-items: center;
        }
        /* Make canvas fluid on small screens */
        canvas {
            width: 90vw; 
            height: 90vw; 
            max-width: 480px; 
            max-height: 480px;
        }
        .playwrap {
            /* Reset playwrap margin/padding to save height. */
            margin: 0; 
            padding-bottom: 10px; 
            width: 100%;
        }
        .controls {
            margin: 15px auto 0;
        }
        
        /* FIX 4: Hide the large desktop title and info in the HUD */
        .hud .title, .hud .hint { 
             display: none; 
        }

        /* FIX 5: Use a dedicated, smaller area for the start/reset buttons on mobile */
        #mobile-buttons {
            display: flex;
            gap: 8px;
            max-width: 300px;
            width: 100%;
            margin: 0 auto 10px auto; 
            padding: 10px 0 0 0;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
    }
    /* Hide mobile-specific div on desktop */
    #mobile-buttons {
        display: none;
    }

    .playwrap{display:flex;flex-direction:column;align-items:center;gap:8px}
    .title{
        font-size:28px;
        font-weight:700;
        color: #e6eef8; 
        text-shadow: 0 0 8px rgba(230, 238, 248, 0.3); 
        margin-bottom:4px;
        text-align:center;
        transition: color 0.2s ease-out, text-shadow 0.2s ease-out; 
    }
    
    .hud-footer{
        display:flex;
        flex-direction:column;
        gap: 10px;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    /* CUSTOM MODAL STYLES START */
    #confirm-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none; 
        justify-content: center;
        align-items: center;
        z-index: 1000;
        backdrop-filter: blur(4px);
    }
    .modal-content {
        background: var(--card);
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        max-width: 350px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    .modal-content p {
        margin: 0;
        font-size: 16px;
        font-weight: 500;
        line-height: 1.4;
    }
    .modal-buttons {
        display: flex;
        justify-content: space-around;
        gap: 10px;
    }
    .modal-buttons .btn {
        flex-grow: 1;
        padding: 10px;
        font-size: 16px;
    }
    /* CUSTOM MODAL STYLES END */
    
    /* MOBILE CONTROLS STYLES */
    .controls {
        display: grid;
        grid-template-areas: ". up ." "left center right" ". down .";
        gap: 8px;
        width: 150px; 
        margin: 20px auto 0;
    }
    .control-btn {
        grid-area: var(--area);
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--accent);
        cursor: pointer;
        transition: background 0.1s, transform 0.05s;
        -webkit-tap-highlight-color: transparent; 
    }
    .control-btn:active,
    .control-btn.key-press-simulated { 
        background: rgba(34, 197, 94, 0.2);
        transform: scale(0.95);
    }

    /* Assign grid areas */
    #up-btn { --area: up; }
    #down-btn { --area: down; }
    #left-btn { --area: left; }
    #right-btn { --area: right; }
    
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="playwrap">
        <canvas id="game" width="480" height="480"></canvas>
        
        <div class="controls">
            <button id="up-btn" class="control-btn" data-dir="up">▲</button>
            <div id="center-spacer" style="grid-area: center; visibility: hidden;"></div>
            <button id="left-btn" class="control-btn" data-dir="left">◀</button>
            <button id="right-btn" class="control-btn" data-dir="right">▶</button>
            <button id="down-btn" class="control-btn" data-dir="down">▼</button>
        </div>
        
      </div>
      <div id="mobile-buttons">
          <button id="start-mobile" class="btn primary">Start</button>
          <button id="reset-mobile" class="btn">Reset</button>
      </div>
      
      <div class="hud">
        <div class="title">Byte Serpent</div>
        <div class="row"><div class="big">Score</div><div id="score">0</div></div>
        <div class="row"><div class="big">Best</div><div id="best">0</div></div>
        <div class="row"><div class="hint">Speed</div><div id="speed">6</div></div>
        <div id="desktop-buttons" style="display:flex;gap:8px">
          <button id="start" class="btn primary">Start</button>
          <button id="reset" class="btn">Reset</button>
        </div>
        <div class="hint">Controls: <span class="green-control">Arrow keys</span> / <span class="green-control">WASD</span></div>
        <div class="hint">Try to eat the <span class="red-warning">RED FOOD</span>. Don't hit the <span class="red-warning">WALLS</span> or <span class="red-warning">YOURSELF</span>.</div>
        
        <div class="hud-footer">
            <button id="reset-all" class="btn danger">Reset All</button>
        </div>
        </div>
    </div>
  </div>
  
  <div id="confirm-modal">
    <div class="modal-content">
        <p>Are you sure you want to wipe your Best Score?</p>
        <p class="hint" style="color: #ef4444; font-weight: 600;">THIS ACTION CANNOT BE UNDONE.</p>
        <div class="modal-buttons">
            <button id="confirm-no" class="btn">No</button>
            <button id="confirm-yes" class="btn success">Yes, Reset All</button>
        </div>
    </div>
  </div>
  <script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const speedEl = document.getElementById('speed');
// Desktop Buttons
const startBtn = document.getElementById('start');
const resetBtn = document.getElementById('reset');
// Mobile Buttons (New IDs)
const startMobileBtn = document.getElementById('start-mobile');
const resetMobileBtn = document.getElementById('reset-mobile');

const titleEl = document.querySelector('.title'); 
const resetAllBtn = document.getElementById('reset-all');

// Custom Modal elements
const confirmModal = document.getElementById('confirm-modal');
const confirmYesBtn = document.getElementById('confirm-yes');
const confirmNoBtn = document.getElementById('confirm-no');

// Get score/best labels
const scoreLabelEl = scoreEl.parentElement.querySelector('.big');
const bestLabelEl = bestEl.parentElement.querySelector('.big');

// New Control elements
const controlBtns = document.querySelectorAll('.control-btn');
// Map keyboard keys to control button IDs
const keyMap = {
    'ArrowUp': 'up-btn', 'w': 'up-btn', 'W': 'up-btn',
    'ArrowDown': 'down-btn', 's': 'down-btn', 'S': 'down-btn',
    'ArrowLeft': 'left-btn', 'a': 'left-btn', 'A': 'left-btn',
    'ArrowRight': 'right-btn', 'd': 'right-btn', 'D': 'right-btn'
};

const gridSize = 20;
const cols = canvas.width / gridSize;
const rows = canvas.height / gridSize;

let snake;
let dir;
let nextDir;
let food;

let tickInterval;
let tickTimer = null;

let running = false;
let dead = false;

let score = 0;
let best = Number(localStorage.getItem('snake_best') || 0);
bestEl.textContent = best;

// Function to handle direction setting (used by both keyboard and buttons)
function setDirection(newDir) {
  nextDir = newDir;
  if (dead) {
    resetGame();
    startGame();
  } else if (!running) {
    startGame();
  }
}

// Function to simulate the click animation
function simulateKeyPress(key) {
    const btnId = keyMap[key];
    if (btnId) {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.classList.add('key-press-simulated');
            // Remove the class after a short delay (e.g., 100ms)
            setTimeout(() => {
                btn.classList.remove('key-press-simulated');
            }, 100);
        }
    }
}

// --- Event Listeners for Custom Controls (On-Screen Buttons) ---
controlBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
        const direction = e.currentTarget.getAttribute('data-dir');
        let newDir = null;
        
        switch (direction) {
            case 'up': newDir = { x: 0, y: -1 }; break;
            case 'down': newDir = { x: 0, y: 1 }; break;
            case 'left': newDir = { x: -1, y: 0 }; break;
            case 'right': newDir = { x: 1, y: 0 }; break;
        }
        
        if (newDir) {
            setDirection(newDir);
        }
    });
});


// Function to reset all data (including high score) - Triggered by modal 'Yes'
function executeResetAll() {
    // 1. Clear best score from local storage
    localStorage.removeItem('snake_best');
    
    // 2. Reset the best variable
    best = 0;
    
    // 3. Reset the current game
    resetGame();

    // 4. Hide the modal
    confirmModal.style.display = 'none';
}

// Function to show the custom confirmation modal - Triggered by 'Reset All' button
function showResetAllConfirmation() {
    confirmModal.style.display = 'flex';
}

// RESET GAME
function resetGame(){
  snake = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
  dir = {x:1, y:0};
  nextDir = {x:1, y:0};

  placeFood();
  score = 0;
  tickInterval = 1000 / 6;

  running = false;
  dead = false;

  clearInterval(tickTimer);
  updateHud();
  
  // Reset styles on game reset
  titleEl.style.color = '';
  titleEl.style.textShadow = '';
  canvas.style.boxShadow = '';
  
  // Set ALL elements to "alive" green color (var(--accent) is #22c55e)
  scoreLabelEl.style.color = 'var(--accent)';
  scoreEl.style.color = 'var(--accent)';
  bestLabelEl.style.color = 'var(--accent)';
  bestEl.style.color = 'var(--accent)';
  
  draw();
}

function placeFood(){
  while(true){
    const x = Math.floor(Math.random()*cols);
    const y = Math.floor(Math.random()*rows);
    if(!snake.some(s => s.x===x && s.y===y)){
      food = {x,y};
      return;
    }
  }
}

function startGame(){
  if(running || dead) return;
  running = true;
  restartTicker();
}

function restartTicker(){
  clearInterval(tickTimer);
  tickTimer = setInterval(step, tickInterval);
}

function step(){
  if(nextDir.x !== -dir.x || nextDir.y !== -dir.y){
    dir = nextDir;
  }

  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

  if(head.x<0 || head.x>=cols || head.y<0 || head.y>=rows){
    gameOver(); return;
  }
  if(snake.some(s => s.x===head.x && s.y===head.y)){
    gameOver(); return;
  }

  snake.unshift(head);

  if(head.x === food.x && head.y === food.y){
    score++;
    placeFood();

    if(score % 3 === 0){
      tickInterval = Math.max(40, tickInterval * 0.9);
      restartTicker();
    }
  } else {
    snake.pop();
  }

  updateHud();
  draw();
}

function gameOver(){
  running = false;
  dead = true;
  clearInterval(tickTimer);

  const isNewBest = score > best;

  if(isNewBest){
    best = score;
    localStorage.setItem('snake_best', String(best));
  }
  updateHud();

  // Define colors
  const redColor = '#ff4444';
  const redGlow = '0 0 8px rgba(255, 68, 68, 0.5)';
  
  const goldColor = '#FFD700'; // Gold color for new record
  const goldGlow = '0 0 10px 5px rgba(255, 215, 0, 0.4)';
  
  let primaryColor, shadowGlow, canvasGlow;
  
  if (isNewBest) {
    primaryColor = goldColor;
    shadowGlow = '0 0 8px ' + primaryColor;
    canvasGlow = goldGlow;
  } else {
    primaryColor = redColor;
    shadowGlow = redGlow;
    canvasGlow = '0 0 0 4px rgba(255, 50, 50, 0.3)';
  }

  // Apply colors and glows
  canvas.style.boxShadow = canvasGlow;
  
  titleEl.style.color = primaryColor;
  titleEl.style.textShadow = shadowGlow;
  
  // Score is always colored by the primary color (Red or Gold)
  scoreLabelEl.style.color = primaryColor;
  scoreEl.style.color = primaryColor;
  
  // Best is only colored by the primary color (Gold) if it's a new best, otherwise it retains green.
  if (isNewBest) {
    bestLabelEl.style.color = primaryColor;
    bestEl.style.color = primaryColor;
  }

  draw();
}

function updateHud(){
  scoreEl.textContent = score;
  bestEl.textContent = best;
  speedEl.textContent = Math.round(1000/tickInterval);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#03151b';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // FOOD → RED
  drawCell(food.x, food.y, '#ff4444');

  for(let i=snake.length-1;i>=0;i--){
    const s = snake[i];
    if(i===0) drawCell(s.x,s.y,'#8ef7b6', true, dir); // Pass 'dir' for head
    else drawCell(s.x,s.y,'#1de38a');
  }

  // Draw grid lines, making the outer ones brighter and thicker
  for(let x=0;x<=cols;x++){
    if(x === 0 || x === cols){
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
    } else {
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
    }
    ctx.beginPath(); ctx.moveTo(x*gridSize,0); ctx.lineTo(x*gridSize,canvas.height); ctx.stroke();
  }
  for(let y=0;y<=rows;y++){
    if(y === 0 || y === rows){
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
    } else {
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
    }
    ctx.beginPath(); ctx.moveTo(0,y*gridSize); ctx.lineTo(canvas.width,y*gridSize); ctx.stroke();
  }
  ctx.lineWidth = 1; // Reset line width
}

function drawCell(cx, cy, color, isHead=false, currentDir = {x:1, y:0}){ // Added currentDir parameter
  const px = cx * gridSize;
  const py = cy * gridSize;
  const pad = 2;

  if(isHead){
    const g = ctx.createLinearGradient(px,py,px+gridSize,py+gridSize);
    g.addColorStop(0,color);
    g.addColorStop(1,'#0fffc2');
    ctx.fillStyle = g;
  } else ctx.fillStyle = color;

  roundRect(ctx, px+pad, py+pad, gridSize-2*pad, gridSize-2*pad, 6);
  ctx.fill();

  // Draw arrow on snake head
  if(isHead) {
    ctx.fillStyle = '#ff4444'; // Arrow color (RED for contrast)
    ctx.beginPath();

    const arrowSize = gridSize * 0.25; // Smaller size of the arrow relative to the cell
    const centerX = px + gridSize / 2;
    const centerY = py + gridSize / 2;

    if (currentDir.x === 1) { // Right
        ctx.moveTo(centerX + arrowSize/2, centerY);
        ctx.lineTo(centerX - arrowSize/2, centerY - arrowSize/2);
        ctx.lineTo(centerX - arrowSize/2, centerY + arrowSize/2);
    } else if (currentDir.x === -1) { // Left
        ctx.moveTo(centerX - arrowSize/2, centerY);
        ctx.lineTo(centerX + arrowSize/2, centerY - arrowSize/2);
        ctx.lineTo(centerX + arrowSize/2, centerY + arrowSize/2);
    } else if (currentDir.y === 1) { // Down
        ctx.moveTo(centerX, centerY + arrowSize/2);
        ctx.lineTo(centerX - arrowSize/2, centerY - arrowSize/2);
        ctx.lineTo(centerX + arrowSize/2, centerY - arrowSize/2);
    } else if (currentDir.y === -1) { // Up
        ctx.moveTo(centerX, centerY - arrowSize/2);
        ctx.lineTo(centerX - arrowSize/2, centerY + arrowSize/2);
        ctx.lineTo(centerX + arrowSize/2, centerY + arrowSize/2);
    }
    ctx.closePath();
    ctx.fill();
  }
}

function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y, x+w,y+h, r);
  ctx.arcTo(x+w,y+h, x,y+h, r);
  ctx.arcTo(x,y+h, x,y, r);
  ctx.arcTo(x,y, x+w,y, r);
  ctx.closePath();
}

// KEYBOARD INPUT + AUTO-START AFTER DEATH
window.addEventListener('keydown', e => {
  const k = e.key;

  let newDir = null;

  if(k==='ArrowUp'||k==='w'||k==='W'){ newDir={x:0,y:-1}; }
  if(k==='ArrowDown'||k==='s'||k==='S'){ newDir={x:0,y:1}; }
  if(k==='ArrowLeft'||k==='a'||k==='A'){ newDir={x:-1,y:0}; }
  if(k==='ArrowRight'||k==='d'||k==='D'){ newDir={x:1,y:0}; }

  if(newDir){
    // 1. Prevent the default action (like scrolling) for movement keys
    e.preventDefault(); 
    
    // 2. Simulate the button press animation
    simulateKeyPress(k);
    
    // 3. Set the direction and potentially start the game
    setDirection(newDir);
  }

  if(k===' '){
    // Prevent the default action (like scrolling) for the Spacebar
    e.preventDefault(); 
    if(dead){
      resetGame();
    } else if(!running){
      startGame();
    }
  }
});

// DESKTOP button listeners
startBtn.addEventListener('click', startGame);
resetBtn.addEventListener('click', resetGame);

// MOBILE button listeners
startMobileBtn.addEventListener('click', startGame);
resetMobileBtn.addEventListener('click', resetGame);

// --- Event Listeners for Custom Modal ---
resetAllBtn.addEventListener('click', showResetAllConfirmation);
confirmYesBtn.addEventListener('click', executeResetAll);
confirmNoBtn.addEventListener('click', () => {
    confirmModal.style.display = 'none';
});

// --- Dynamic Element Reordering for Mobile View ---
(function dynamicLayoutAdjustment() {
    const isMobile = window.innerWidth <= 720;
    const desktopButtonsContainer = document.getElementById('desktop-buttons');
    const mobileButtonsContainer = document.getElementById('mobile-buttons');

    if (isMobile) {
        const card = document.querySelector('.card');
        const playwrap = document.querySelector('.playwrap');
        const hud = document.querySelector('.hud');
        
        // Desired order on mobile: Playwrap (Canvas/Controls) -> Mobile Buttons -> HUD (Score)
        if (card && playwrap && hud && mobileButtonsContainer) {
            // Re-order the children of the card container
            card.appendChild(playwrap); 
            card.appendChild(mobileButtonsContainer);
            card.appendChild(hud); 
        }
        
        // Hide desktop-only buttons
        if (desktopButtonsContainer) {
             desktopButtonsContainer.style.display = 'none';
        }
    } else {
        // Hide mobile-only button container on desktop
        if (mobileButtonsContainer) {
            mobileButtonsContainer.style.display = 'none';
        }
    }
})();


resetGame();
</script>
</body>
</html>
